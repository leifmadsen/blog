<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bash on Asterisk, and other worldly endeavours</title>
    <link>http://blog.leifmadsen.com/tags/bash/</link>
    <description>Recent content in Bash on Asterisk, and other worldly endeavours</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Sep 2015 21:20:40 +0000</lastBuildDate>
    <atom:link href="http://blog.leifmadsen.com/tags/bash/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Configuring powerline to show working Git branch</title>
      <link>http://blog.leifmadsen.com/blog/2015/09/09/configuring-powerline-to-show-working-git-branch/</link>
      <pubDate>Wed, 09 Sep 2015 21:20:40 +0000</pubDate>
      
      <guid>http://blog.leifmadsen.com/blog/2015/09/09/configuring-powerline-to-show-working-git-branch/</guid>
      <description>&lt;p&gt;So the documentation for &lt;a href=&#34;http://powerline.readthedocs.org/en/latest/index.html&#34;&gt;Powerline&lt;/a&gt;Â kind of sucks. I followed &lt;a href=&#34;http://fedoramagazine.org/add-power-terminal-powerline&#34;&gt;this&lt;/a&gt; pretty good article on getting started with it. First thing I noticed however is that the &lt;code&gt;if&lt;/code&gt; statement on the article doesn&amp;rsquo;t work if you don&amp;rsquo;t have powerline installed (which kind of defeats the purpose of having the &lt;code&gt;if&lt;/code&gt; statement there at all).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# if powerline is installed, then use it
command -v powerline-daemon &amp;amp;&amp;gt;/dev/null
if [ $? -eq 0 ]; then
powerline-daemon -q
POWERLINE_BASH_CONTINUATION=1
POWERLINE_BASH_SELECT=1
. /usr/share/powerline/bash/powerline.sh
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next up is the configuration. I primarily use my bash prompt as a way to indicate which branch I&amp;rsquo;m working in within a Git repository. You need to point at the &lt;code&gt;default_leftonly&lt;/code&gt; theme which is pretty easy to find when you web search for it. The issue is everything seems to just point you at the powerline docs, which aren&amp;rsquo;t the most clear.&lt;/p&gt;

&lt;p&gt;First, start by creating a local configuration directory that will override the configuration for powerline for your user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir -p ~/.config/powerline
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the next thing is to copy over the &lt;code&gt;config.json&lt;/code&gt; from the main powerline configuration directory where you can find the available color schemes and other shell, i3, vim, etc themes.&lt;/p&gt;

&lt;p&gt;(Again, the documentation kind of sucks on where the root of these configurations live&amp;hellip;)&lt;/p&gt;

&lt;p&gt;On my Fedora 22 system they live in &lt;code&gt;/etc/xdg/powerline/&lt;/code&gt;. I then copy the &lt;code&gt;config.json&lt;/code&gt; from that directory to &lt;code&gt;~/.config/powerline&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To get the Git branch stuff going, I modified the configuration file in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;--- /etc/xdg/powerline/config.json 2015-02-18 18:56:51.000000000 -0500
+++ /home/lmadsen/.config/powerline/config.json 2015-09-09 17:11:43.937522571 -0400
@@ -18,7 +18,7 @@
},
&amp;quot;shell&amp;quot;: {
&amp;quot;colorscheme&amp;quot;: &amp;quot;default&amp;quot;,
- &amp;quot;theme&amp;quot;: &amp;quot;default&amp;quot;,
+ &amp;quot;theme&amp;quot;: &amp;quot;default_leftonly&amp;quot;,
&amp;quot;local_themes&amp;quot;: {
&amp;quot;continuation&amp;quot;: &amp;quot;continuation&amp;quot;,
&amp;quot;select&amp;quot;: &amp;quot;select&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make it active you can run &lt;code&gt;powerline-config --reload&lt;/code&gt;. If you have any errors in your configuration (I actually ran into this when playing with the colorscheme setting and used &amp;ldquo;solorized&amp;rdquo; instead of &amp;ldquo;solarized&amp;rdquo;), you can check it with &lt;code&gt;powerline-lint&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Selecting Chef Servers With Environment Variables</title>
      <link>http://blog.leifmadsen.com/blog/2012/08/22/selecting-chef-servers-with-environment-variables/</link>
      <pubDate>Wed, 22 Aug 2012 18:49:43 +0000</pubDate>
      
      <guid>http://blog.leifmadsen.com/blog/2012/08/22/selecting-chef-servers-with-environment-variables/</guid>
      <description>&lt;p&gt;Today I got playing around with dynamically selecting different chef servers in preparation for migrating some of &lt;a href=&#34;http://coredial.com&#34;&gt;our&lt;/a&gt; nodes away from our chef-dev server to our chef-live server (which I&amp;rsquo;m currently in the process of building and populating with data). I had been talking in the #chef IRC channel a few weeks back about making things dynamic, or at least easily switchable, when using multiple chef servers for different groups of servers in an environment.&lt;/p&gt;

&lt;p&gt;What I want to do, is be able to set an environment variable at my console in order to switch between chef servers. Previously I had been doing this with different files in my ~/.chef/ directory and changing symlinks between the files. This method works, but is kind of annoying. So with the help of some of the folks in #chef, and with &lt;a href=&#34;https://gist.github.com/3176332&#34;&gt;this gist&lt;/a&gt; of a sample file that someone is using for their hosted chef environment, I was able to build my own knife.rb and commit it to our chef.git repository.&lt;/p&gt;

&lt;p&gt;In our &lt;strong&gt;chef.git&lt;/strong&gt; repository, I created a directory &lt;strong&gt;.chef&lt;/strong&gt; and placed a &lt;strong&gt;knife.rb&lt;/strong&gt; file in it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd ~/src/chef-repo
$ mkdir .chef
$ touch .chef/knife.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I then filled &lt;strong&gt;knife.rb&lt;/strong&gt; with the following contents:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;current_dir = File.dirname(__FILE__)

sys_user = ENV[&amp;quot;USER&amp;quot;]

log_level                :info
log_location             STDOUT
node_name                sys_user
client_key               &amp;quot;#{ENV[&amp;quot;HOME&amp;quot;]}/.chef/#{ENV[&amp;quot;KNIFE_ENV&amp;quot;]}/#{ENV[&amp;quot;USER&amp;quot;]}.pem&amp;quot;
validation_client_name   &amp;quot;chef-validator&amp;quot;
validation_key           &amp;quot;#{ENV[&amp;quot;HOME&amp;quot;]}/.chef/#{ENV[&amp;quot;KNIFE_ENV&amp;quot;]}/validator.pem&amp;quot;
chef_server_url          &amp;quot;http://chef-#{ENV[&amp;quot;KNIFE_ENV&amp;quot;]}.shifteight.org:4000&amp;quot;
cache_type               &#39;BasicFile&#39;
cache_options( :path =&amp;gt; &amp;quot;#{ENV[&#39;HOME&#39;]}/.chef/checksums&amp;quot; )
cookbook_path            [ &amp;quot;#{current_dir}/../cookbooks&amp;quot;, &amp;quot;#{current_dir}/../site-cookbooks&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main key is the KNIFE_ENV environment variable which I set using: &lt;code&gt;export KNIFE_ENV=dev&lt;/code&gt; or &lt;code&gt;export KNIFE_ENV=live&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;After setting the environment variable, which server I&amp;rsquo;m using is selected for me. Additionally, I copied my validation.pem and client.pem files into corresponding directories in my ~/.chef/ directory: &lt;code&gt;$ mkdir ~/.chef/{live,dev}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;With all that done, I can now easily switch between our different servers in order to start the migration of our nodes. (I might create another blog post about that in the future if I get a chance.)&lt;/p&gt;

&lt;p&gt;&amp;ldquo;BUT HOW DO I KNOW WHICH ENVIRONMENT I&amp;rsquo;M WORKING WITH?!?!?!&amp;rdquo;, you say? Oh fancy this little PS1 and function I added to my ~/.bashrc file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;if [ &amp;quot;$KNIFE_ENV&amp;quot; == &amp;quot;&amp;quot; ]; then
 export KNIFE_ENV=&amp;quot;dev&amp;quot;
fi

function which_env {
  if [ &amp;quot;$KNIFE_ENV&amp;quot; == &amp;quot;live&amp;quot; ]; then
    echo &amp;quot;31&amp;quot;
  else
    echo &amp;quot;32&amp;quot;
  fi
}

export PS1=&#39;[\u@\h \[\033[0;36m\]\W$(__git_ps1 &amp;quot;\[\033[0m\]\[\033[0;33m\](%s) \[\033[0;`which_env`m\]~$KNIFE_ENV~&amp;quot;)\[\033[0m\]]\$ &#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Is nice :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bash creating files named &#39;1&#39; everywhere!</title>
      <link>http://blog.leifmadsen.com/blog/2012/07/19/bash-creating-files-named-1-everywhere/</link>
      <pubDate>Thu, 19 Jul 2012 15:03:05 +0000</pubDate>
      
      <guid>http://blog.leifmadsen.com/blog/2012/07/19/bash-creating-files-named-1-everywhere/</guid>
      <description>&lt;p&gt;So I ran into something kind of stupid today :)  Adding a little note for anyone who might run into a similar instance.&lt;/p&gt;

&lt;p&gt;I have some &lt;code&gt;ssh-add&lt;/code&gt; stuff that gets run in my &lt;code&gt;.bashrc&lt;/code&gt; file, but when I was outputting it, I was doing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-add ~/.ssh/some_key &amp;gt; /dev/null 2&amp;amp;&amp;gt;1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the &lt;code&gt;2&amp;amp;&amp;gt;1&lt;/code&gt; at the end. That means to redirect output to a file named 1. You need to flip the &lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt; into &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, so the fixed version looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-add ~/.ssh/some_key &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>rpmlint non-utf8-spec-file error</title>
      <link>http://blog.leifmadsen.com/blog/2012/02/23/rpmlint-non-utf8-spec-file-error/</link>
      <pubDate>Thu, 23 Feb 2012 18:43:54 +0000</pubDate>
      
      <guid>http://blog.leifmadsen.com/blog/2012/02/23/rpmlint-non-utf8-spec-file-error/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been doing a bunch of work with RPMs lately, and while running rpmlint against a spec file I was modifying, I received this error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;myfile.spec: E: non-utf8-spec-file myfile.spec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After Googling, I ran into a way of finding the non-compliant characters.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ iconv -f ISO-8859-8 -t UTF-8 myfile.spec &amp;gt; converted.spec
$ diff -u myfile.spec converted.spec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Answer thanks to Dominique Leuenberger @ &lt;a href=&#34;http://lists.opensuse.org/opensuse-packaging/2011-04/msg00005.html&#34;&gt;http://lists.opensuse.org/opensuse-packaging/2011-04/msg00005.html&lt;/a&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>.bashrc trick for git repo and branch information</title>
      <link>http://blog.leifmadsen.com/blog/2011/12/22/.bashrc-trick-for-git-repo-and-branch-information/</link>
      <pubDate>Thu, 22 Dec 2011 14:39:07 +0000</pubDate>
      
      <guid>http://blog.leifmadsen.com/blog/2011/12/22/.bashrc-trick-for-git-repo-and-branch-information/</guid>
      <description>&lt;p&gt;The other day I was talking to my friend &lt;a href=&#34;http://russellbryant.net&#34;&gt;Russell Bryant&lt;/a&gt; who pointed me to some .bashrc magic that would show me which branch I was currently working with inside a git repo on my system. I found it incredibly handy and have modified the ANSI colour coding slightly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export PS1=&#39;[\u@\h \[33[0;36m\]\W$(__git_ps1 &amp;quot;\[33[0m\]\[33[0;33m\](%s)&amp;quot;)\[33[0m\]]\$ &#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On Fedora Russell mentioned that you need the &lt;code&gt;bash-completion&lt;/code&gt; installed. We&amp;rsquo;re unsure if you need anything on other distributions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Edit: January 6, 2012_
As I&amp;rsquo;m using my laptop today, I modified the .bashrc file on Ubuntu 10.04, and here is the PS1 code I came up with. It&amp;rsquo;s nearly the same, but I&amp;rsquo;m using bold today instead of the unbolded colours of lore.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;PS1=&#39;${debian_chroot:+($debian_chroot)}\[\033[28;01m\]\u@\h\[\033[00m\]:\[\033[1;36m\]\W$(__git_ps1 &amp;quot;\[\033[00m\]\[\033[1;33m\](%s)&amp;quot;)\[\033[00m\]\$ &#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Return just PID of script with &#39;ps&#39; and &#39;awk&#39;</title>
      <link>http://blog.leifmadsen.com/blog/2011/09/15/return-just-pid-of-script-with-ps-and-awk/</link>
      <pubDate>Thu, 15 Sep 2011 12:34:35 +0000</pubDate>
      
      <guid>http://blog.leifmadsen.com/blog/2011/09/15/return-just-pid-of-script-with-ps-and-awk/</guid>
      <description>&lt;p&gt;Today I ran into an issue where I am running a python script that I needed to get the process ID (PID) of, but that the process was being output with a space between &amp;lsquo;python&amp;rsquo; and the actual script name (in this case, jiraircbot.py).&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m sure it&amp;rsquo;s totally overkill and there is a much easier way I didn&amp;rsquo;t find to do this, but after some scouring of The Google, I found something that works! (The purpose of this was to kill off a rogue script process each night so I could restart it.)&lt;/p&gt;

&lt;p&gt;Here is what the output looks like with just &lt;code&gt;ps aux | grep python&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ps aux | grep python
root      1120  0.0  0.2  50176  4380 ?        Sl   Aug04  24:52 /usr/bin/python /usr/bin/fail2ban-server -b -s /var/run/fail2ban/fail2ban.sock
root     18182  2.2  1.5  35328 32148 pts/0    S    08:21   0:11 python jiraircbot.py
root     18219  0.0  0.0   3328   804 pts/0    S+   08:29   0:00 grep python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A little bit more data than I wanted, plus of course &amp;lsquo;grep python&amp;rsquo; is always going to be returned if I just use grep straight up. Putting many pieces together from a few websites, this is what I came up with to just return the PID of the jiraircbot.py script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ps -eo pid,command | grep &amp;quot;jiraircbot.py&amp;quot; | grep -v grep | awk &#39;{print $1}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What I&amp;rsquo;m doing, is controlling what is returned, so in this case have &lt;code&gt;ps&lt;/code&gt; just return the pid and command fields. Run that through &lt;code&gt;grep&lt;/code&gt; to just get the script I wanted, pipe that back through &lt;code&gt;grep&lt;/code&gt; to remove the line including &lt;code&gt;grep python&lt;/code&gt; and then pipe that through &lt;code&gt;awk&lt;/code&gt; to just return the first field (which would be the pid of the process I wanted).&lt;/p&gt;

&lt;p&gt;All in all, a nice hack :)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>